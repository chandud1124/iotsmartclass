// -----------------------------------------------------------------------------
// Enhanced ESP32 <-> Backend WebSocket implementation with offline functionality
// Supports operation without WiFi/backend connection and prevents crashes
// Endpoint: ws://<HOST>:3001/esp32-ws  (server.js)
// -----------------------------------------------------------------------------
// Core messages:
//  -> identify      {type:'identify', mac, secret}
//  <- identified    {type:'identified', mode, switches:[{gpio,relayGpio,name,...}]}
//  <- config_update {type:'config_update', switches:[...]}  (after UI edits)
//  <- switch_command{type:'switch_command', gpio|relayGpio, state}
//  -> state_update  {type:'state_update', switches:[{gpio,state}]}
//  -> heartbeat     {type:'heartbeat', uptime}
//  <- state_ack     {type:'state_ack', changed}
// -----------------------------------------------------------------------------

#include <WiFi.h>
#include <WebSocketsClient.h>
#include <ArduinoJson.h>
#include <EEPROM.h>
#include <Ticker.h>
#include "config.h"
// Uncomment to compile without mbedtls/HMAC (for older cores or minimal builds)
// #define DISABLE_HMAC 1
#ifndef DISABLE_HMAC
#include <mbedtls/md.h>
#endif

#define WIFI_SSID "I am Not A Witch I am Your Wifi"
#define WIFI_PASSWORD "Whoareu@0000"
#define BACKEND_HOST "192.168.0.108"  // backend LAN IP
#define BACKEND_PORT 3001
#define WS_PATH "/esp32-ws"
#define HEARTBEAT_MS 30000UL          // 30s heartbeat interval
#define DEVICE_SECRET "6af44c010af8ba58514c6fa989c6e6d3469068f2d8da19a4" // device secret from backend

// Optional status LED (set to 255 to disable if your board lacks LED_BUILTIN)
#ifndef STATUS_LED_PIN
#define STATUS_LED_PIN 2
#endif

// Debounce multiple rapid local state changes into one state_update
#define STATE_DEBOUNCE_MS 200

// Command queue size and processing interval
#define MAX_COMMAND_QUEUE 10
#define COMMAND_PROCESS_INTERVAL 100  // Process commands every 100ms

// EEPROM storage for offline persistence
#define EEPROM_CONFIG_START 4  // Start after version byte
#define EEPROM_MAX_SWITCHES 16 // Maximum switches to store in EEPROM

// Scheduling constants
#define MAX_SCHEDULES 10
#define SCHEDULE_CHECK_INTERVAL 60000  // Check schedules every minute

// Active-low mapping: logical ON -> LOW, OFF -> HIGH (common relay boards)

WebSocketsClient ws;
unsigned long lastHeartbeat = 0;
unsigned long lastStateSent = 0;
unsigned long lastScheduleCheck = 0;
unsigned long lastCommandProcess = 0;
bool pendingState = false;
bool identified = false;
bool isOfflineMode = false;
unsigned long lastIdentifyAttempt = 0;
unsigned long lastWifiAttempt = 0;
#define IDENTIFY_RETRY_MS 10000UL // retry identify every 10s until successful
#define WIFI_RETRY_MS 30000UL     // retry WiFi connection every 30s

// Command queue to prevent crashes from multiple simultaneous commands
struct Command {
  int gpio;
  bool state;
  bool valid;
  unsigned long timestamp;
};
Command commandQueue[MAX_COMMAND_QUEUE];
int queueHead = 0;
int queueTail = 0;
bool commandInProgress = false;
Ticker commandDebouncer;

// Extended switch state supports optional manual (wall) switch input GPIO
struct SwitchState {
  int gpio;                    // relay control GPIO (output)
  bool state;                  // logical ON/OFF state
  String name;                 // label from backend
  int manualGpio = -1;         // optional manual switch GPIO (input)
  bool manualEnabled = false;  // whether manual input is active
  bool manualActiveLow = true; // per-switch input polarity (independent of relay polarity)
  bool manualMomentary = false; // true = momentary (toggle on active edge), false = maintained (level maps to state)
  int lastManualLevel = -1;    // last raw digitalRead level
  unsigned long lastManualChangeMs = 0; // last time raw level flipped
  int stableManualLevel = -1;  // debounced level
  bool lastManualActive = false; // previous debounced logical active level (after polarity)
  bool defaultState = false;   // default state for offline mode
  bool manualOverride = false; // whether this switch was manually overridden
};
#define MANUAL_DEBOUNCE_MS 30
// Treat a falling edge (HIGH->LOW) on a pullup input as a toggle event
#define MANUAL_ACTIVE_LOW 1
#include <vector>
std::vector<SwitchState> switchesLocal; // dynamically populated

// Simple schedule structure for offline scheduling
struct Schedule {
  int hour;
  int minute;
  bool isOn;
  int daysOfWeek;  // Bit field: bit 0 = Sunday, bit 1 = Monday, etc.
  int targetGpio;
  bool enabled;
};
Schedule schedules[MAX_SCHEDULES];
int numSchedules = 0;

// -----------------------------------------------------------------------------
// Utility helpers
// -----------------------------------------------------------------------------
void sendJson(const JsonDocument &doc) {
  if (!ws.isConnected()) return;
  
  String out; serializeJson(doc, out);
  ws.sendTXT(out);
}

String hmacSha256(const String &key, const String &msg) {
#ifdef DISABLE_HMAC
  // HMAC disabled: return empty string to skip signing
  (void)key; (void)msg; return String("");
#else
  byte hmacResult[32];
  mbedtls_md_context_t ctx;
  const mbedtls_md_info_t *info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
  mbedtls_md_init(&ctx);
  mbedtls_md_setup(&ctx, info, 1);
  mbedtls_md_hmac_starts(&ctx, (const unsigned char*)key.c_str(), key.length());
  mbedtls_md_hmac_update(&ctx, (const unsigned char*)msg.c_str(), msg.length());
  mbedtls_md_hmac_finish(&ctx, hmacResult);
  mbedtls_md_free(&ctx);
  char buf[65];
  for (int i=0;i<32;i++) sprintf(&buf[i*2], "%02x", hmacResult[i]);
  buf[64]='\0';
  return String(buf);
#endif
}

void identify() {
  DynamicJsonDocument doc(256);
  doc["type"] = "identify";
  doc["mac"] = WiFi.macAddress();
  doc["secret"] = DEVICE_SECRET; // simple shared secret (upgrade to HMAC if needed)
  doc["offline_capable"] = true;  // Indicate this device supports offline mode
  sendJson(doc);
  lastIdentifyAttempt = millis();
}

void sendStateUpdate(bool force=false) {
  unsigned long now = millis();
  if (!force && now - lastStateSent < STATE_DEBOUNCE_MS) { pendingState = true; return; }
  pendingState = false;
  lastStateSent = now;
  
  // Don't try to send if not connected
  if (!ws.isConnected()) return;
  
  DynamicJsonDocument doc(512);
  doc["type"] = "state_update";
  doc["seq"] = (long)(millis()); // coarse monotonic seq for state_update
  doc["ts"] = (long)(millis());
  JsonArray arr = doc.createNestedArray("switches");
  for (auto &sw : switchesLocal) {
    JsonObject o = arr.createNestedObject();
    o["gpio"] = sw.gpio;
    o["state"] = sw.state;
    o["manual_override"] = sw.manualOverride;
  }
  if (strlen(DEVICE_SECRET) > 0) {
    String base = WiFi.macAddress();
    base += "|"; base += (long)doc["seq"]; base += "|"; base += (long)doc["ts"];
    doc["sig"] = hmacSha256(DEVICE_SECRET, base);
  }
  sendJson(doc);
  Serial.println(F("[WS] -> state_update"));
}

void sendHeartbeat() {
  if (!ws.isConnected()) return;
  
  DynamicJsonDocument doc(256);
  doc["type"] = "heartbeat";
  doc["mac"] = WiFi.macAddress();
  doc["uptime"] = millis()/1000;
  doc["offline_mode"] = isOfflineMode;
  sendJson(doc);
}

// Track last applied sequence per GPIO to drop stale commands
struct GpioSeq { int gpio; long seq; };
static std::vector<GpioSeq> lastSeqs;
long getLastSeq(int gpio){ for(auto &p: lastSeqs){ if(p.gpio==gpio) return p.seq; } return -1; }
void setLastSeq(int gpio,long seq){ for(auto &p: lastSeqs){ if(p.gpio==gpio){ p.seq=seq; return;} } lastSeqs.push_back({gpio,seq}); }

// Add command to queue instead of executing immediately
void queueSwitchCommand(int gpio, bool state) {
  int nextTail = (queueTail + 1) % MAX_COMMAND_QUEUE;
  if (nextTail != queueHead) { // Queue not full
    commandQueue[queueTail].gpio = gpio;
    commandQueue[queueTail].state = state;
    commandQueue[queueTail].valid = true;
    commandQueue[queueTail].timestamp = millis();
    queueTail = nextTail;
    Serial.printf("[CMD] Queued command: GPIO %d -> %s\n", gpio, state ? "ON" : "OFF");
  } else {
    Serial.println("[CMD] Command queue full, dropping command");
  }
}

// Process commands from the queue with debouncing
void processCommandQueue() {
  if (queueHead == queueTail || commandInProgress) return; // Queue empty or command in progress
  
  unsigned long now = millis();
  if (now - lastCommandProcess < COMMAND_PROCESS_INTERVAL) return; // Not time to process yet
  
  lastCommandProcess = now;
  
  if (commandQueue[queueHead].valid) {
    int gpio = commandQueue[queueHead].gpio;
    bool state = commandQueue[queueHead].state;
    
    // Set flag to prevent multiple commands processing at once
    commandInProgress = true;
    
    // Process the command
    applySwitchState(gpio, state);
    
    // Clear this command
    commandQueue[queueHead].valid = false;
    
    // Schedule the flag to be cleared after a delay
    commandDebouncer.once_ms(100, []() {
      commandInProgress = false;
    });
  }
  
  // Move to next command
  queueHead = (queueHead + 1) % MAX_COMMAND_QUEUE;
}

bool applySwitchState(int gpio, bool state) {
  for (auto &sw : switchesLocal) {
    if (sw.gpio == gpio) {
      sw.state = state;
      pinMode(sw.gpio, OUTPUT);
      digitalWrite(sw.gpio, state ? LOW : HIGH);
      Serial.printf("[SWITCH] GPIO %d -> %s (active-low)\n", sw.gpio, state ? "ON":"OFF");
      
      // Save state to EEPROM for offline persistence
      sw.defaultState = state;
      saveConfigToEEPROM();
      
      sendStateUpdate(true); // immediate broadcast
      return true;
    }
  }
  Serial.printf("[SWITCH] Unknown GPIO %d (ignored)\n", gpio);
  return false;
}

void loadConfigFromJsonArray(JsonArray arr) {
  switchesLocal.clear();
  for (JsonObject o : arr) {
    int g = o["relayGpio"].is<int>() ? o["relayGpio"].as<int>() : (o["gpio"].is<int>() ? o["gpio"].as<int>() : -1);
    if (g < 0) continue;
    bool desiredState = o["state"].is<bool>() ? o["state"].as<bool>() : false; // default OFF logically
    SwitchState sw { };
    sw.gpio = g;
    sw.state = desiredState;
    sw.defaultState = desiredState;  // Store default state for offline mode
    sw.name = String(o["name"].is<const char*>() ? o["name"].as<const char*>() : "");
    sw.manualOverride = false;
    
    // Manual switch config (optional)
    if (o["manualSwitchEnabled"].is<bool>() && o["manualSwitchEnabled"].as<bool>() && o["manualSwitchGpio"].is<int>()) {
      sw.manualEnabled = true;
      sw.manualGpio = o["manualSwitchGpio"].as<int>();
      // Parse manualMode (maintained | momentary) and polarity
      if (o["manualMode"].is<const char*>()) {
        const char *mm = o["manualMode"].as<const char*>();
        sw.manualMomentary = (strcmp(mm, "momentary") == 0);
      }
      if (o["manualActiveLow"].is<bool>()) {
        sw.manualActiveLow = o["manualActiveLow"].as<bool>();
      }
    }
    pinMode(g, OUTPUT);
    digitalWrite(g, desiredState ? LOW : HIGH);
    if (sw.manualEnabled && sw.manualGpio >= 0) {
      // Configure input with proper pull depending on polarity.
      // NOTE: GPIOs 34-39 are input-only and DO NOT support internal pull-up/down.
      // For those pins, we set INPUT and require an external resistor.
      if (sw.manualGpio >= 34 && sw.manualGpio <= 39) {
        pinMode(sw.manualGpio, INPUT);
        Serial.printf("[MANUAL][WARN] gpio=%d is input-only (34-39) without internal pull resistors. Use external pull-%s.\n",
                      sw.manualGpio, sw.manualActiveLow ? "up to 3.3V" : "down to GND");
      } else {
        if (sw.manualActiveLow) {
          pinMode(sw.manualGpio, INPUT_PULLUP); // active when pulled LOW (to GND)
        } else {
          // Many ESP32 pins support internal pulldown; if not available, add external pulldown
          pinMode(sw.manualGpio, INPUT_PULLDOWN);
        }
      }
      sw.lastManualLevel = digitalRead(sw.manualGpio);
      sw.stableManualLevel = sw.lastManualLevel;
      // Initialize active logical level after polarity mapping
      sw.lastManualActive = sw.manualActiveLow ? (sw.stableManualLevel == LOW) : (sw.stableManualLevel == HIGH);
      Serial.printf("[MANUAL][INIT] gpio=%d (input %d) activeLow=%d mode=%s raw=%d active=%d\n",
                    sw.gpio, sw.manualGpio, sw.manualActiveLow ? 1 : 0,
                    sw.manualMomentary ? "momentary" : "maintained",
                    sw.stableManualLevel, sw.lastManualActive ? 1 : 0);
    }
    switchesLocal.push_back(sw);
  }
  Serial.printf("[CONFIG] Loaded %u switches\n", (unsigned)switchesLocal.size());
  // Snapshot print for verification
  for (auto &sw : switchesLocal) {
    Serial.printf("[SNAPSHOT] gpio=%d state=%s manual=%s manualGpio=%d mode=%s activeLow=%d\n",
                  sw.gpio, sw.state?"ON":"OFF", sw.manualEnabled?"yes":"no", sw.manualGpio,
                  sw.manualMomentary?"momentary":"maintained", sw.manualActiveLow?1:0);
  }
  
  // Save configuration to EEPROM for offline persistence
  saveConfigToEEPROM();
  
  sendStateUpdate(true);
}

// Save configuration to EEPROM for offline persistence
void saveConfigToEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  
  // Save number of switches
  int numSwitches = min((int)switchesLocal.size(), EEPROM_MAX_SWITCHES);
  EEPROM.write(EEPROM_CONFIG_START, numSwitches);
  
  // Save switch configurations
  int addr = EEPROM_CONFIG_START + 1;
  for (int i = 0; i < numSwitches; i++) {
    EEPROM.write(addr++, switchesLocal[i].gpio);
    EEPROM.write(addr++, switchesLocal[i].state ? 1 : 0);
    EEPROM.write(addr++, switchesLocal[i].defaultState ? 1 : 0);
    EEPROM.write(addr++, switchesLocal[i].manualEnabled ? 1 : 0);
    EEPROM.write(addr++, switchesLocal[i].manualGpio);
    EEPROM.write(addr++, switchesLocal[i].manualActiveLow ? 1 : 0);
    EEPROM.write(addr++, switchesLocal[i].manualMomentary ? 1 : 0);
  }
  
  // Save schedules
  EEPROM.write(addr++, numSchedules);
  for (int i = 0; i < numSchedules; i++) {
    EEPROM.write(addr++, schedules[i].hour);
    EEPROM.write(addr++, schedules[i].minute);
    EEPROM.write(addr++, schedules[i].isOn ? 1 : 0);
    EEPROM.write(addr++, schedules[i].daysOfWeek);
    EEPROM.write(addr++, schedules[i].targetGpio);
    EEPROM.write(addr++, schedules[i].enabled ? 1 : 0);
  }
  
  EEPROM.commit();
  EEPROM.end();
  
  Serial.println("[EEPROM] Configuration saved");
}

// Load configuration from EEPROM for offline persistence
void loadConfigFromEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  
  // Check if we have valid data
  int numSwitches = EEPROM.read(EEPROM_CONFIG_START);
  if (numSwitches > EEPROM_MAX_SWITCHES) {
    Serial.println("[EEPROM] Invalid switch count, using defaults");
    EEPROM.end();
    return;
  }
  
  // Load switch configurations
  switchesLocal.clear();
  int addr = EEPROM_CONFIG_START + 1;
  for (int i = 0; i < numSwitches; i++) {
    SwitchState sw { };
    sw.gpio = EEPROM.read(addr++);
    sw.state = EEPROM.read(addr++) == 1;
    sw.defaultState = EEPROM.read(addr++) == 1;
    sw.manualEnabled = EEPROM.read(addr++) == 1;
    sw.manualGpio = EEPROM.read(addr++);
    sw.manualActiveLow = EEPROM.read(addr++) == 1;
    sw.manualMomentary = EEPROM.read(addr++) == 1;
    sw.name = String("Switch ") + String(i + 1);
    sw.manualOverride = false;
    
    // Initialize pins
    pinMode(sw.gpio, OUTPUT);
    digitalWrite(sw.gpio, sw.state ? LOW : HIGH);
    
    if (sw.manualEnabled && sw.manualGpio >= 0) {
      if (sw.manualGpio >= 34 && sw.manualGpio <= 39) {
        pinMode(sw.manualGpio, INPUT);
      } else {
        if (sw.manualActiveLow) {
          pinMode(sw.manualGpio, INPUT_PULLUP);
        } else {
          pinMode(sw.manualGpio, INPUT_PULLDOWN);
        }
      }
      sw.lastManualLevel = digitalRead(sw.manualGpio);
      sw.stableManualLevel = sw.lastManualLevel;
      sw.lastManualActive = sw.manualActiveLow ? (sw.stableManualLevel == LOW) : (sw.stableManualLevel == HIGH);
    }
    
    switchesLocal.push_back(sw);
  }
  
  // Load schedules
  numSchedules = EEPROM.read(addr++);
  if (numSchedules > MAX_SCHEDULES) numSchedules = MAX_SCHEDULES;
  
  for (int i = 0; i < numSchedules; i++) {
    schedules[i].hour = EEPROM.read(addr++);
    schedules[i].minute = EEPROM.read(addr++);
    schedules[i].isOn = EEPROM.read(addr++) == 1;
    schedules[i].daysOfWeek = EEPROM.read(addr++);
    schedules[i].targetGpio = EEPROM.read(addr++);
    schedules[i].enabled = EEPROM.read(addr++) == 1;
  }
  
  EEPROM.end();
  
  Serial.printf("[EEPROM] Loaded %d switches and %d schedules\n", numSwitches, numSchedules);
}

void onWsEvent(WStype_t type, uint8_t * payload, size_t len) {
  switch (type) {
    case WStype_CONNECTED:
      Serial.println("WS connected");
      identified = false;
      isOfflineMode = false;
      if (STATUS_LED_PIN != 255) digitalWrite(STATUS_LED_PIN, LOW);
      identify();
      break;
    case WStype_TEXT: {
      // Use try-catch to prevent crashes from malformed JSON
      try {
        DynamicJsonDocument doc(1024);
        if (deserializeJson(doc, payload, len) != DeserializationError::Ok) {
          Serial.println(F("[WS] JSON parse error"));
          return;
        }
        const char* msgType = doc["type"] | "";
        if (strcmp(msgType, "identified") == 0) {
          identified = true;
          isOfflineMode = false;
          if (STATUS_LED_PIN != 255) digitalWrite(STATUS_LED_PIN, HIGH);
          const char* _mode = doc["mode"].is<const char*>() ? doc["mode"].as<const char*>() : "n/a";
          Serial.printf("[WS] <- identified mode=%s\n", _mode);
          // Reset per-GPIO sequence tracking on fresh identify to avoid stale_seq after server restarts
          lastSeqs.clear();
          if (doc["switches"].is<JsonArray>()) loadConfigFromJsonArray(doc["switches"].as<JsonArray>());
          else Serial.println(F("[CONFIG] No switches in identified payload (using none)"));
          
          // Load schedules if provided
          if (doc["schedules"].is<JsonArray>()) {
            JsonArray schArr = doc["schedules"].as<JsonArray>();
            numSchedules = min((int)schArr.size(), MAX_SCHEDULES);
            for (int i = 0; i < numSchedules; i++) {
              JsonObject sch = schArr[i];
              schedules[i].hour = sch["hour"] | 0;
              schedules[i].minute = sch["minute"] | 0;
              schedules[i].isOn = sch["isOn"] | false;
              schedules[i].daysOfWeek = sch["daysOfWeek"] | 0;
              schedules[i].targetGpio = sch["targetGpio"] | 0;
              schedules[i].enabled = sch["enabled"] | false;
            }
            saveConfigToEEPROM();
          }
          return;
        }
        if (strcmp(msgType, "config_update") == 0) {
          if (doc["switches"].is<JsonArray>()) {
            Serial.println(F("[WS] <- config_update"));
            // Clear seq tracking as mapping may change
            lastSeqs.clear();
            loadConfigFromJsonArray(doc["switches"].as<JsonArray>());
          }
          
          // Update schedules if provided
          if (doc["schedules"].is<JsonArray>()) {
            JsonArray schArr = doc["schedules"].as<JsonArray>();
            numSchedules = min((int)schArr.size(), MAX_SCHEDULES);
            for (int i = 0; i < numSchedules; i++) {
              JsonObject sch = schArr[i];
              schedules[i].hour = sch["hour"] | 0;
              schedules[i].minute = sch["minute"] | 0;
              schedules[i].isOn = sch["isOn"] | false;
              schedules[i].daysOfWeek = sch["daysOfWeek"] | 0;
              schedules[i].targetGpio = sch["targetGpio"] | 0;
              schedules[i].enabled = sch["enabled"] | false;
            }
            saveConfigToEEPROM();
          }
          return;
        }
        if (strcmp(msgType, "state_ack") == 0) {
          bool changed = doc["changed"] | false;
          Serial.printf("[WS] <- state_ack changed=%s\n", changed ? "true":"false");
          return;
        }
        if (strcmp(msgType, "switch_command") == 0) {
          int gpio = doc["relayGpio"].is<int>() ? doc["relayGpio"].as<int>() : (doc["gpio"].is<int>() ? doc["gpio"].as<int>() : -1);
          bool requested = doc["state"] | false;
          long seq = doc["seq"].is<long>() ? doc["seq"].as<long>() : -1;
          Serial.printf("[CMD] Raw: %.*s\n", (int)len, payload);
          Serial.printf("[CMD] switch_command gpio=%d state=%s seq=%ld\n", gpio, requested ? "ON":"OFF", seq);
          
          // Queue the command instead of executing immediately
          if (gpio >= 0) {
            queueSwitchCommand(gpio, requested);
          }
          
          // Drop stale if older than last applied for this gpio
          if (seq >= 0) {
            long last = getLastSeq(gpio);
            if (last >= 0 && seq < last) {
              Serial.printf("[CMD] drop stale seq (last=%ld)\n", last);
              // Still send a result so backend can ignore
              DynamicJsonDocument res(192);
              res["type"] = "switch_result";
              res["gpio"] = gpio;
              res["requestedState"] = requested;
              res["success"] = false;
              res["reason"] = "stale_seq";
              res["seq"] = seq;
              sendJson(res);
              return;
            }
            setLastSeq(gpio, seq);
          }
          
          // Send explicit result so backend can reconcile UI if failure
          DynamicJsonDocument res(192);
          res["type"] = "switch_result";
          res["gpio"] = gpio;
          res["requestedState"] = requested;
          res["success"] = gpio >= 0;
          if (seq >= 0) res["seq"] = seq;
          res["ts"] = (long)millis();
          
          if (strlen(DEVICE_SECRET) > 0) {
            String base = WiFi.macAddress();
            base += "|"; base += gpio;
            base += "|"; base += (gpio >= 0 ? 1 : 0);
            base += "|"; base += (requested ? 1 : 0);
            bool actual = false; 
            for (auto &sw : switchesLocal) if (sw.gpio == gpio) { actual = sw.state; break; }
            res["actualState"] = actual;
            base += "|"; base += (actual ? 1 : 0);
            base += "|"; base += (long)res["seq"];
            base += "|"; base += (long)res["ts"];
            res["sig"] = hmacSha256(DEVICE_SECRET, base);
          }
          
          if (gpio < 0) {
            res["reason"] = "invalid_gpio";
          } else {
            // find actual state to echo
            for (auto &sw : switchesLocal) if (sw.gpio == gpio) { res["actualState"] = sw.state; break; }
          }
          sendJson(res);
          return;
        }
        Serial.printf("[WS] <- unhandled type=%s Raw=%.*s\n", msgType, (int)len, payload);
      } catch (const std::exception& e) {
        Serial.print("Exception in WebSocket handler: ");
        Serial.println(e.what());
      }
      break; 
    }
    case WStype_DISCONNECTED:
      Serial.println("WS disconnected");
      identified = false;
      isOfflineMode = true;
      if (STATUS_LED_PIN != 255) digitalWrite(STATUS_LED_PIN, LOW);
      break;
    default: break;
  }
}

void setupRelays() {
  // Initially no switches (dynamic config arrives after identify).
  // If you want fallback default pins, push_back them here.
  if (switchesLocal.empty()) {
    Serial.println(F("[INIT] No local switches yet (waiting for identified/config_update)"));
    
    // Try to load configuration from EEPROM for offline mode
    loadConfigFromEEPROM();
    
    // If still empty, create some default switches
    if (switchesLocal.empty()) {
      Serial.println(F("[INIT] Creating default switches for offline mode"));
      // Example default configuration - adjust pins as needed
      int defaultPins[] = {12, 14, 27, 26};
      int defaultManualPins[] = {32, 33, 34, 35};
      
      for (int i = 0; i < 4; i++) {
        SwitchState sw { };
        sw.gpio = defaultPins[i];
        sw.state = false;
        sw.defaultState = false;
        sw.name = String("Switch ") + String(i + 1);
        sw.manualEnabled = true;
        sw.manualGpio = defaultManualPins[i];
        sw.manualActiveLow = true;
        sw.manualMomentary = true;
        sw.manualOverride = false;
        
        pinMode(sw.gpio, OUTPUT);
        digitalWrite(sw.gpio, HIGH);  // OFF (active low)
        
        if (sw.manualGpio >= 34 && sw.manualGpio <= 39) {
          pinMode(sw.manualGpio, INPUT);
        } else {
          pinMode(sw.manualGpio, INPUT_PULLUP);
        }
        
        sw.lastManualLevel = digitalRead(sw.manualGpio);
        sw.stableManualLevel = sw.lastManualLevel;
        sw.lastManualActive = sw.manualActiveLow ? (sw.stableManualLevel == LOW) : (sw.stableManualLevel == HIGH);
        
        switchesLocal.push_back(sw);
      }
      
      // Save default configuration
      saveConfigToEEPROM();
    }
  } else {
    for (auto &sw : switchesLocal) {
      pinMode(sw.gpio, OUTPUT);
      // Ensure hardware reflects stored logical state (active-low)
      digitalWrite(sw.gpio, sw.state ? LOW : HIGH);
    }
  }
}

// Check and execute scheduled actions
void checkSchedules() {
  if (numSchedules == 0) return;
  
  unsigned long now = millis();
  if (now - lastScheduleCheck < SCHEDULE_CHECK_INTERVAL) return;
  
  lastScheduleCheck = now;
  
  // Get current time
  time_t rawtime;
  struct tm* timeinfo;
  time(&rawtime);
  timeinfo = localtime(&rawtime);
  
  int currentHour = timeinfo->tm_hour;
  int currentMinute = timeinfo->tm_min;
  int currentDay = timeinfo->tm_wday;  // 0 = Sunday, 1 = Monday, etc.
  int currentDayBit = 1 << currentDay;
  
  for (int i = 0; i < numSchedules; i++) {
    if (!schedules[i].enabled) continue;
    
    // Check if schedule matches current time and day
    if (schedules[i].hour == currentHour && 
        schedules[i].minute == currentMinute && 
        (schedules[i].daysOfWeek & currentDayBit)) {
      
      // Execute the scheduled action
      int targetGpio = schedules[i].targetGpio;
      bool targetState = schedules[i].isOn;
      
      Serial.printf("[SCHEDULE] Executing schedule %d: GPIO %d -> %s\n", 
                   i, targetGpio, targetState ? "ON" : "OFF");
      
      // Find the switch and apply the state if not manually overridden
      for (auto &sw : switchesLocal) {
        if (sw.gpio == targetGpio && !sw.manualOverride) {
          applySwitchState(targetGpio, targetState);
          break;
        }
      }
    }
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println("\nESP32 Classroom Automation System Starting...");
  
  // EEPROM init and optional clear on version bump
  EEPROM.begin(EEPROM_SIZE);
  const int verAddr = 0;
  int storedVer = EEPROM.read(verAddr);
  if (storedVer != CONFIG_VERSION) {
    Serial.printf("[EEPROM] Version mismatch (stored=%d, expected=%d). Clearing...\n", storedVer, CONFIG_VERSION);
    for (int i=0;i<EEPROM_SIZE;i++) EEPROM.write(i, 0);
    EEPROM.write(verAddr, CONFIG_VERSION);
    EEPROM.commit();
  }
  
  // Initialize command queue
  for (int i = 0; i < MAX_COMMAND_QUEUE; i++) {
    commandQueue[i].valid = false;
  }
  
  // Start in offline mode
  isOfflineMode = true;
  
  // Setup relays and load configuration from EEPROM if available
  setupRelays();
  
  if (STATUS_LED_PIN != 255) { 
    pinMode(STATUS_LED_PIN, OUTPUT); 
    digitalWrite(STATUS_LED_PIN, LOW); 
  }
  
  // Try to connect to WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi");
  
  // Try to connect for 10 seconds, then continue in offline mode if unsuccessful
  unsigned long startAttempt = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 10000) {
    delay(500);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    
    // Configure time
    configTime(0, 0, "pool.ntp.org");
    
    // Setup WebSocket connection
    ws.begin(BACKEND_HOST, BACKEND_PORT, WS_PATH);
    ws.onEvent(onWsEvent);
    ws.setReconnectInterval(5000);
    isOfflineMode = false;
  } else {
    Serial.println("\nWiFi connection failed, operating in offline mode");
    isOfflineMode = true;
  }
  
  lastHeartbeat = millis();
  lastScheduleCheck = millis();
  lastCommandProcess = millis();
  
  Serial.println("Setup complete!");
}

void loop() {
  // Process commands from the queue
  processCommandQueue();
  
  // Check WiFi connection and try to reconnect if needed
  if (WiFi.status() != WL_CONNECTED) {
    if (!isOfflineMode) {
      Serial.println("WiFi disconnected, switching to offline mode");
      isOfflineMode = true;
    }
    
    // Try to reconnect periodically
    unsigned long now = millis();
    if (now - lastWifiAttempt > WIFI_RETRY_MS) {
      Serial.println("Attempting to reconnect WiFi...");
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      lastWifiAttempt = now;
      
      // Wait briefly for connection
      unsigned long startAttempt = now;
      while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 5000) {
        delay(500);
      }
      
      if (WiFi.status() == WL_CONNECTED) {
        Serial.println("WiFi reconnected!");
        isOfflineMode = false;
        
        // Reconnect WebSocket
        ws.disconnect();
        ws.begin(BACKEND_HOST, BACKEND_PORT, WS_PATH);
      }
    }
  } else {
    // Handle WebSocket connection
    ws.loop();
    
    // If we have a websocket connection but haven't been identified yet, retry identify periodically
    if (!identified && (millis() - lastIdentifyAttempt) > IDENTIFY_RETRY_MS) {
      identify();
    }
  }
  
  // Flush a pending coalesced state update when debounce interval elapsed
  if (pendingState && (millis() - lastStateSent) >= STATE_DEBOUNCE_MS) {
    sendStateUpdate();
  }
  
  // Poll manual (wall) switches for changes with debounce
  unsigned long now = millis();
  bool anyManualToggled = false;
  for (auto &sw : switchesLocal) {
    if (!sw.manualEnabled || sw.manualGpio < 0) continue;
    
    int lvl = digitalRead(sw.manualGpio);
    if (lvl != sw.lastManualLevel) {
      sw.lastManualLevel = lvl;
      sw.lastManualChangeMs = now; // start debounce window
      Serial.printf("[MANUAL][RAW] input=%d level=%d at %lu ms\n", sw.manualGpio, lvl, (unsigned long)now);
    }
    
    // Apply debounce: only update stable level after debounce time
    if (now - sw.lastManualChangeMs >= MANUAL_DEBOUNCE_MS && sw.stableManualLevel != sw.lastManualLevel) {
      sw.stableManualLevel = sw.lastManualLevel;
      // Convert raw level to logical active state based on polarity
      bool isActive = sw.manualActiveLow ? (sw.stableManualLevel == LOW) : (sw.stableManualLevel == HIGH);
      
      // Handle based on switch mode
      if (sw.manualMomentary) {
        // Momentary: toggle on active edge (inactive->active transition)
        if (isActive && !sw.lastManualActive) {
          // Toggle the switch
          sw.state = !sw.state;
          sw.manualOverride = true;  // Mark as manually overridden
          digitalWrite(sw.gpio, sw.state ? LOW : HIGH);
          Serial.printf("[MANUAL] Toggled GPIO %d to %s\n", sw.gpio, sw.state ? "ON" : "OFF");
          anyManualToggled = true;
        }
      } else {
        // Maintained: state follows switch position
        if (isActive != sw.state) {
          sw.state = isActive;
          sw.manualOverride = true;  // Mark as manually overridden
          digitalWrite(sw.gpio, sw.state ? LOW : HIGH);
          Serial.printf("[MANUAL] Set GPIO %d to %s\n", sw.gpio, sw.state ? "ON" : "OFF");
          anyManualToggled = true;
        }
      }
      sw.lastManualActive = isActive;
    }
  }
  
  // Send state update if any manual switch was toggled
  if (anyManualToggled) {
    sendStateUpdate(true);
    saveConfigToEEPROM();  // Save state changes to EEPROM
  }
  
  // Send heartbeat to server
  if (millis() - lastHeartbeat > HEARTBEAT_MS) {
    sendHeartbeat();
    lastHeartbeat = millis();
  }
  
  // Check and execute scheduled actions
  if (WiFi.status() == WL_CONNECTED) {
    checkSchedules();
  }
  
  // Small delay to prevent CPU hogging
  delay(10);
}
